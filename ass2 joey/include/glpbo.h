/* !
\file		glpbo.h
\author		pghali@digipen.edu
@date    10/11/2016
@co-author joeyjunyu.c@digipen.edu
@date    30/06/2023
@ammendmants added additional features
void GLPbo::emulate()
void GLPbo::draw_fullwindow_quad()
void GLPbo::init(GLsizei w, GLsizei h)
void GLPbo::setup_quad_vao()
void GLPbo::setup_shdrpgm()


This file provides the implementation of the GLPbo struct, provides functionalities for managing and rendering an OpenGL application.
It includes functions for managing texture objects, application states, vertex array objects, shaders, and animations.
*//*__________________________________________________________________________*/

/*                                                                      guard
----------------------------------------------------------------------------- */
#ifndef GLPBO_H
#define GLPBO_H
/*                                                                   includes
----------------------------------------------------------------------------- */
#include <GL/glew.h> // for access to OpenGL API declarations 
#include <glhelper.h>
#include <glslshader.h> // GLSLShader class definition
#include <GLFW/glfw3.h> 
#include <dpml.h>
#include <array>
#include <cmath>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <fstream>
#include <random>
#include <chrono>
#include <cctype>
#include <map>
#include <glm/gtc/matrix_transform.hpp>

/*  _________________________________________________________________________ */
struct GLPbo
{
    struct Vertex
    {
        glm::vec2 pos;
        glm::vec2 textCord;
    };
    // forward declaration
    union Color;

    //-------------- static member function declarations here -----------------

    // this is where the emulator does its work of emulating the graphics pipe
    // it generates images using set_pixel to write to the PBO
    static void emulate();

    // render quad using the texture image generated by emulate()
    // also prints appropriate information to window's title bar ...
    static void draw_fullwindow_quad();

    // initialization and cleanup stuff ...
    static void init(GLsizei w, GLsizei h);
    static void setup_quad_vao();
    static void setup_shdrpgm();
    static void cleanup();

    struct PointLight {
        glm::vec3 intensity; // we choose to not store the alpha component
        glm::vec3 position;
    };
    struct Model {
        std::vector<glm::vec3> pm; 
        
        std::vector<glm::vec3> nml; 
       
        std::vector<glm::vec2> tex; 
        std::vector<unsigned short> tri; // triangle indices

        std::vector<glm::vec3> pd;


        bool isRotating = false;
        float angle = 0.0f;
        glm::mat3 modelTransform;
        enum class modelType {
            wireframe = 0,
            depthBuffer,
            faceted,
            shaded,
            textured
        } Tasking = GLPbo::Model::modelType::wireframe;

    };
    static Model mdl;



    static void viewport_xform(Model& mdl);

    static void render_linebresenham(GLint px0, GLint py0,
        GLint px1, GLint py1, GLPbo::Color draw_clr);
    static bool render_triangle_faceted(glm::dvec3 const& p0, glm::dvec3 const& p1, glm::dvec3 const& p2,
        glm::vec3 const& vert1, glm::vec3 const& vert2, glm::vec3 const& vert3);
    //static bool render_triangle(glm::dvec3 const& p0, glm::dvec3 const& p1, glm::dvec3 const& p2,
    //    glm::dvec3 const& c0, glm::dvec3 const& c1, glm::dvec3 const& c2);
    static bool render_shadow_map(glm::dvec3 const& p0, glm::dvec3 const& p1,
        glm::dvec3 const& p2);

    static bool render_shadow_map_light(glm::dvec3 const& p0, glm::dvec3 const& p1, glm::dvec3 const& p2,
        glm::vec3 const& c0, glm::vec3 const& c1, glm::vec3 const& c2,
        glm::vec3 const& vert1, glm::vec3 const& vert2, glm::vec3 const& vert3);
    static void set_pixel(int x, int y, Color clr); // Write RGBAcolor at pixel with window coordinates
    static bool render_texture_map(glm::dvec3 const& p0, glm::dvec3 const& p1, glm::dvec3 const& p2
        , glm::dvec2 const& texCord0, glm::dvec2 const& texCord1, glm::dvec2 const& texCord2);

    // ---------------static data members are declared here ----------------

    // Storage requirements common to emulator, PBO and texture object
    static GLsizei width, height; // dimensions of buffers
    // rather than computing these values many times, compute once in
    // GLPbo::init() and then forget ...
    static GLsizei pixel_cnt, byte_cnt; // how many pixels and bytes
    // pointer to PBO's data store - must be set every frame with  
    // the value returned by glMapNamedBuffer()

    static Color* ptr_to_pbo;
    static GLuint vaoid;
    static GLuint elem_cnt;
    static GLuint pboid;
    static GLuint texid;
    static GLSLShader shdr_pgm;
    static double * depthBuffer;
    static void set_clear_color(GLPbo::Color);
    static void set_clear_color(GLubyte _r, GLubyte _g, GLubyte _b, GLubyte _a = 255);
    static void clear_depth_buffer();

    static void clear_color_buffer();

    static void setup_texobj(std::string pathname);
    static Color clear_clr;

    union Color
        /*! glm doesn't have type unsigned char [4] - therefore we declare our
        own type.
        Since Color is such a common type name in graphics applications, make
        sure to encapsulate the name in scope GLPbo!!!
        */
    {
        struct {
            GLubyte r, g, b, a; // a, b, g, r
        }rgba;
        GLubyte val[4] = { 0,0,0,0 }; // treat <r,g,b,a> as array of 8-bit unsigned values
        GLuint raw;     // treat <r,g,b,a> as 32-bit unsigned value

        Color(GLubyte re = 0, GLubyte gr = 0, GLubyte bl = 0, GLubyte al = 255) :
            rgba{ re, gr, bl, al } {}
    };

};

#endif /* GLPBO_H */
